<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Piece Knowledge Graph Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab.active {
            color: #2196F3;
            border-bottom-color: #2196F3;
        }
        .tab:hover {
            color: #2196F3;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        #graph {
            width: 100%;
            height: 700px;
            display: flex;
            flex-direction: column;
        }
        #graph-container {
            flex: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #graph-viz {
            width: 100%;
            height: 100%;
            flex: 1;
        }
        .file-selector {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .file-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        .file-selector select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            border-left: 4px solid #2196F3;
        }
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: #2196F3;
        }
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
        .search {
            margin-bottom: 20px;
        }
        .search input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .table-container {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }
        .class-tree {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
            overflow: auto;
        }
        .class-item {
            padding: 5px 0;
            cursor: pointer;
        }
        .class-item:hover {
            background: #e3f2fd;
        }
        .indent {
            padding-left: 30px;
        }
        .class-name {
            color: #1976d2;
            font-weight: 600;
        }
        .property-list {
            margin-top: 5px;
            padding-left: 20px;
            color: #666;
            font-size: 14px;
        }
        .triple-view {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            max-height: 600px;
            overflow-y: auto;
        }
        .triple {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-left: 3px solid #2196F3;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        .subject { color: #1976d2; }
        .predicate { color: #388e3c; }
        .object { color: #d32f2f; }
        .filters {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .filter-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .filter-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè¥‚Äç‚ò†Ô∏è One Piece Knowledge Graph Explorer</h1>
        <p class="subtitle">Explore the structured data of the One Piece universe</p>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('overview')">Overview</button>
            <button class="tab" onclick="showTab('browse')">Browse Characters</button>
            <button class="tab" onclick="showTab('structure')">Ontology Structure</button>
            <button class="tab" onclick="showTab('triples')">Triple View</button>
            <button class="tab" onclick="showTab('raw')">Raw Data</button>
        </div>

        <div id="overview" class="tab-content active">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="stat-characters">-</div>
                    <div class="stat-label">Characters</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="stat-triples">-</div>
                    <div class="stat-label">Total Triples</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="stat-classes">-</div>
                    <div class="stat-label">Classes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="stat-properties">-</div>
                    <div class="stat-label">Properties</div>
                </div>
            </div>
            <h3>About This Dataset</h3>
            <p>This knowledge graph contains structured data about the One Piece universe, including characters, their relationships, and attributes. The data is represented in RDF (Resource Description Framework) using the Turtle syntax.</p>
            <p>Use the tabs above to explore the graph visually, browse the data in tables, or view the raw RDF.</p>
        </div>

        <div id="graph" class="tab-content">
            <div class="file-selector">
                <label for="file-select">Select file(s) to visualize:</label>
                <select id="file-select" onchange="reloadGraph()">
                    <option value="both">Both (Ontology + Entities)</option>
                    <option value="OnePieceEntities.ttl">OnePieceEntities.ttl</option>
                    <option value="onepiece-ontology.ttl">onepiece-ontology.ttl</option>
                </select>
            </div>
            <div class="loading">Loading graph visualization...</div>
            <div id="graph-container" style="display:none;">
                <div id="graph-viz"></div>
            </div>
        </div>

        <div id="browse" class="tab-content">
            <div class="search">
                <input type="text" id="search-input" placeholder="Search by English or Japanese name..." onkeyup="filterTable()">
            </div>
            <div class="filters" id="type-filters"></div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>English Name</th>
                            <th>Japanese Name</th>
                            <th>Type</th>
                            <th>Additional Info</th>
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <tr><td colspan="4" class="loading">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="structure" class="tab-content">
            <h3>Ontology Class Hierarchy</h3>
            <div id="class-tree" class="class-tree">
                <div class="loading">Loading ontology structure...</div>
            </div>
        </div>

        <div id="triples" class="tab-content">
            <div class="search">
                <input type="text" id="triple-search" placeholder="Filter triples..." onkeyup="filterTriples()">
            </div>
            <div id="triple-view" class="triple-view">
                <div class="loading">Loading triples...</div>
            </div>
        </div>

        <div id="raw" class="tab-content">
            <h3>onepiece-ontology.ttl</h3>
            <pre id="ontology-raw">Loading...</pre>
            <h3 style="margin-top: 30px;">OnePieceEntities.ttl</h3>
            <pre id="entities-raw">Loading...</pre>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/n3/browser/n3.min.js"></script>
    <script>
        let allQuads = [];
        let entities = [];
        let currentNetwork = null;

        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        async function loadData(fileSelection = 'both') {
            try {
                let ontologyText = '';
                let entitiesText = '';

                // Load files based on selection
                if (fileSelection === 'both') {
                    const [ontologyResponse, entitiesResponse] = await Promise.all([
                        fetch('onepiece-ontology.ttl'),
                        fetch('OnePieceEntities.ttl')
                    ]);
                    ontologyText = await ontologyResponse.text();
                    entitiesText = await entitiesResponse.text();
                } else if (fileSelection === 'onepiece-ontology.ttl') {
                    const response = await fetch('onepiece-ontology.ttl');
                    ontologyText = await response.text();
                } else if (fileSelection === 'OnePieceEntities.ttl') {
                    const response = await fetch('OnePieceEntities.ttl');
                    entitiesText = await response.text();
                }

                // Display raw data (always load both for raw view)
                if (fileSelection === 'both') {
                    document.getElementById('ontology-raw').textContent = ontologyText;
                    document.getElementById('entities-raw').textContent = entitiesText;
                }

                // Parse RDF
                const parser = new N3.Parser();
                const quads = [];

                // Parse selected files
                const combinedText = ontologyText + '\n' + entitiesText;
                parser.parse(combinedText, (error, quad, prefixes) => {
                    if (quad) {
                        quads.push(quad);
                    } else {
                        processQuads(quads, fileSelection === 'both');
                    }
                });

            } catch (error) {
                console.error('Error:', error);
                showError('Failed to load data. Make sure the RDF files are accessible.');
            }
        }

        function reloadGraph() {
            const fileSelect = document.getElementById('file-select');
            const selectedFile = fileSelect.value;

            // Clear existing graph
            const graphViz = document.getElementById('graph-viz');
            graphViz.innerHTML = '';

            // Show loading
            document.querySelector('#graph .loading').style.display = 'block';
            document.getElementById('graph-container').style.display = 'none';

            // Destroy existing network
            if (currentNetwork) {
                currentNetwork.destroy();
                currentNetwork = null;
            }

            // Reload data with selected file
            loadData(selectedFile);
        }

        function processQuads(quads, updateStats = true) {
            // Calculate statistics
            const subjects = new Set();
            const classes = new Set();
            const properties = new Set();
            const entityMap = new Map();
            const classHierarchy = new Map();

            quads.forEach(quad => {
                subjects.add(quad.subject.value);

                if (quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                    classes.add(quad.object.value);

                    // Track characters
                    const charId = quad.subject.value;
                    if (!characters.has(charId)) {
                        characters.set(charId, { id: charId, type: quad.object.value, properties: {} });
                    }
                } else {
                    properties.add(quad.predicate.value);

                    // Add properties to characters
                    const charId = quad.subject.value;
                    if (characters.has(charId)) {
                        const prop = quad.predicate.value.split('#').pop().split('/').pop();
                        const value = quad.object.value;

                        if (quad.predicate.value.includes('label')) {
                            if (quad.object.language === 'en') {
                                characters.get(charId).enName = value;
                            } else if (quad.object.language === 'ja') {
                                characters.get(charId).jaName = value;
                            }
                        }

                        characters.get(charId).properties[prop] = value;
                    }
                }
            });

            // Update stats only when loading both files initially
            if (updateStats) {
                document.getElementById('stat-triples').textContent = quads.length;
                document.getElementById('stat-characters').textContent = characters.size;
                document.getElementById('stat-classes').textContent = classes.size;
                document.getElementById('stat-properties').textContent = properties.size;

                // Populate table
                populateTable(Array.from(characters.values()));
            }

            // Store for graph
            entities = Array.from(characters.values());

            // If graph tab is active, reinitialize graph
            if (document.getElementById('graph').classList.contains('active')) {
                initGraph();
            }
        }

        function populateTable(ents) {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            // Get unique types for filters
            const types = new Set(ents.map(e => e.type?.split(/[#\/]/).pop()).filter(Boolean));
            const filterContainer = document.getElementById('type-filters');
            filterContainer.innerHTML = '<button class="filter-btn active" onclick="filterByType(null)">All</button>';
            types.forEach(type => {
                filterContainer.innerHTML += `<button class="filter-btn" onclick="filterByType('${type}')">${type}</button>`;
            });

            ents.forEach(ent => {
                const row = tbody.insertRow();
                row.className = 'entity-row';
                row.dataset.type = ent.type?.split(/[#\/]/).pop() || '';
                
                row.insertCell(0).textContent = ent.enName || '-';
                row.insertCell(1).textContent = ent.jaName || '-';
                row.insertCell(2).textContent = ent.type?.split(/[#\/]/).pop() || '-';
                
                const propsCell = row.insertCell(3);
                const propCount = Object.keys(ent.props).length;
                propsCell.textContent = `${propCount} properties`;
                propsCell.style.color = '#666';
                propsCell.style.fontSize = '14px';
            });
        }

        function filterByType(type) {
            currentTypeFilter = type;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.querySelectorAll('.entity-row').forEach(row => {
                if (!type || row.dataset.type === type) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        function filterTable() {
            const input = document.getElementById('search-input').value.toLowerCase();
            document.querySelectorAll('.entity-row').forEach(row => {
                const text = row.textContent.toLowerCase();
                const matchesSearch = text.includes(input);
                const matchesType = !currentTypeFilter || row.dataset.type === currentTypeFilter;
                row.style.display = (matchesSearch && matchesType) ? '' : 'none';
            });
        }

        function populateClassTree(hierarchy, classes) {
            const tree = document.getElementById('class-tree');
            tree.innerHTML = '<div style="margin-bottom: 15px; color: #666;">Click on classes to expand/collapse</div>';
            
            // Find root classes (those not in hierarchy as children)
            const children = new Set();
            hierarchy.forEach(kids => kids.forEach(k => children.add(k)));
            
            const roots = Array.from(classes).filter(c => !children.has(c));
            
            roots.forEach(root => {
                renderClass(root, hierarchy, tree, 0);
            });
        }

        function initGraph() {
            const container = document.getElementById('graph-viz');
            document.querySelector('#graph .loading').style.display = 'none';
            document.getElementById('graph-container').style.display = 'flex';

            // Destroy existing network if any
            if (currentNetwork) {
                currentNetwork.destroy();
            }

            // Create nodes and edges from entities
            const nodes = [];
            const edges = [];

            entities.slice(0, 100).forEach((entity, idx) => {  // Increased to 100 for better visualization
                nodes.push({
                    id: idx,
                    label: entity.enName || entity.jaName || 'Unknown',
                    title: `${entity.enName || ''}\n${entity.jaName || ''}\nType: ${entity.type?.split('#').pop() || 'Unknown'}`,
                    group: entity.type?.split('#').pop() || 'Character'
                });
            });

            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: { size: 12 }
                },
                physics: {
                    enabled: true,
                    stabilization: { iterations: 100 },
                    barnesHut: {
                        gravitationalConstant: -2000,
                        centralGravity: 0.3,
                        springLength: 95,
                        springConstant: 0.04
                    }
                },
                interaction: {
                    hover: true,
                    zoomView: true,
                    dragView: true
                }
            };

            currentNetwork = new vis.Network(container, data, options);
        }

        // Load on page load
        window.addEventListener('load', loadData);
    </script>
</body>
</html>